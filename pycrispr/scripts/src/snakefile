import glob
import os
import pandas as pd


####LOADING VARIABLES####

#load config file
configfile: "experiment.yaml"

#load variables
library = config["library"]
fasta = config["lib_info"][library]["fasta"]

index = os.path.basename(fasta).split(".",1)[0]
index = f"index_{index}/index_{index}"

sg_length = config["lib_info"][library]["sg_length"]

#load rename info
csv = pd.read_csv("rename.csv")

#check if read files need to be renamed
if not os.path.exists("rename.done"):
    
    OLD_FILES = csv["old"].tolist()
    NEW_FILES = csv["new"].tolist()

    #create sample names
    SAMPLES = [x.replace(".fq.gz","") for x in NEW_FILES]
else:
    
    #create sample names
    SAMPLES = [os.path.basename(x).replace(".fq.gz","") for x in glob.glob("reads/*fq.gz")]
    #remove any pre-existing trimmed fq files from this list
    SAMPLES = [x for x in SAMPLES if not "_trimmed" in x]

#load stats comparisons
COMPARISONS = [value.replace(",","-") for (key,value) in config["stats"]["comparisons"].items()] #commas are not compatible with snakemake report

#remove comparisons with pooled control samples (not supported by BAGEL2)
B_COMPARISONS = [x for x in COMPARISONS if not "-" in x.split("_vs_")[1]]


#set targets for target rule
TARGETS =   ["md5sums/md5sums.txt",
            expand("qc/fastqc/{sample}.html", sample=SAMPLES),
            expand("qc/fastqc/{sample}_fastqc.zip", sample=SAMPLES),
            expand("reads/{sample}_trimmed.fq.gz", sample=SAMPLES),
            "qc/multiqc.html",
            "count/alignment-rates.pdf",
            "count/sequence-coverage.pdf",
            f"{index}.1.ht2",
            ]

#extend target rule with MAGecK targets     
TARGETS.extend([
    expand("mageck/{comparison}/{comparison}.gene_summary.txt", comparison=COMPARISONS),
    expand("mageck/{comparison}/{comparison}.sgrna_summary.txt", comparison=COMPARISONS),
    expand("mageck_flute/{comparison}/{comparison}.volcano.pdf", comparison=COMPARISONS),
    expand("mageck_flute/{comparison}/{comparison}.dot_pos.pdf", comparison=COMPARISONS),
    expand("mageck_flute/{comparison}/{comparison}.dot_neg.pdf", comparison=COMPARISONS),
    expand("mageck_flute/{comparison}/{comparison}.sgrank.pdf", comparison=COMPARISONS)
])

#extend target rule with BAGEL2 targets
TARGETS.extend([
    "bagel2_software/",
    "count/counts-aggregated-bagel2.tsv",
    expand("bagel2/{bcomparison}/{bcomparison}.foldchange", bcomparison=B_COMPARISONS),
    expand("bagel2/{bcomparison}/{bcomparison}.bf", bcomparison=B_COMPARISONS),
    expand("bagel2/{bcomparison}/{bcomparison}.pr", bcomparison=B_COMPARISONS),
    expand("bagel2_plots/{bcomparison}/{bcomparison}.bf.pdf", bcomparison=B_COMPARISONS),
    expand("bagel2_plots/{bcomparison}/{bcomparison}.pr.pdf", bcomparison=B_COMPARISONS),
])



####SNAKEMAKE RULES####

#report location
report: "report/report.rst"

#rules to be run on login node instead of compute node when running on HPC (only very small jobs)
localrules: all, rename, aggregated_counts, plot_alignment_rate, plot_coverage, plot_bf, plot_pr

#extend TARGETS with renamed files if required
if not os.path.exists("rename.done"):
    
    TARGETS.extend(expand("reads/{new_file}", new_file=NEW_FILES)),
    TARGETS.append("rename.done")


#set target rule
rule all:
    input:
        TARGETS



if not os.path.exists("rename.done"):
    
    rule check_md5_sums:
        input:
            expand("reads/{old_file}", old_file=OLD_FILES),
        output:
            "md5sums/md5sums.txt"
        params:
            r1_tag=config["r1_tag"],
        conda:
            "envs/count.yaml"
        script:
            "scripts/check_md5_sums.py"

    rule rename:
        input:
            reads=expand("reads/{old_file}", old_file=OLD_FILES),
            md5sum="md5sums/md5sums.txt"
        output:
            f=expand("reads/{new_file}", new_file=NEW_FILES),
            t=touch("rename.done"),
        run:
            for o,n in zip(list({input.reads})[0], list({output.f})[0]):
                os.rename(o,n)


rule fastqc:
    input:
        "reads/{sample}_trimmed.fq.gz"
    output:
        html="qc/fastqc/{sample}.html",
        zip="qc/fastqc/{sample}_fastqc.zip" # the suffix _fastqc.zip is necessary for multiqc to find the file
    params:
        extra = "--quiet"
    log:
        "logs/fastqc/{sample}.log"
    threads: config["resources"]["fastqc"]["cpu"]
    resources:
        runtime=config["resources"]["fastqc"]["time"]
    wrapper:
        "v1.31.1/bio/fastqc"


rule multiqc:
    input:
        expand("qc/fastqc/{sample}_fastqc.zip", sample=SAMPLES)
    output:
        report("qc/multiqc.html", caption="report/multiqc.rst", category="MultiQC analysis of fastq files")
    params:
        extra="",  # Optional: extra parameters for multiqc.
        use_input_files_only=True, # Optional, use only a.txt and don't search folder samtools_stats for files
    resources:
        runtime=config["resources"]["fastqc"]["time"]
    log:
        "logs/multiqc/multiqc.log"
    wrapper:
        "v1.31.1/bio/multiqc"


rule trim:
    input:
        "reads/{sample}.fq.gz"
    output:
        #temp("reads/{sample}_trimmed.fq.gz"),
        "reads/{sample}_trimmed.fq.gz",
    params:
        sgl=sg_length,
        lt=config["lib_info"][library]["left_trim"],
    threads: config["resources"]["trim"]["cpu"]
    conda:
        "envs/trim.yaml"
    log:
        "logs/trim/{sample}.log",
    resources:
        runtime=config["resources"]["trim"]["time"]
    shell:
        "cutadapt -j {threads} --quality-base 33 -u {params.lt} -l {params.sgl} -o {output} {input}"


rule hisat2_index:
    output:
        f"{index}.1.ht2",
    threads: config["resources"]["count"]["cpu"]
    resources:
        runtime=config["resources"]["count"]["time"]
    log:
        "logs/hisat2_index.log"
    conda:
        "envs/count.yaml"
    shell:
        "hisat2-build -p {threads} {fasta} {index} 2> {log}"


rule count:
    input: 
        fq="reads/{sample}_trimmed.fq.gz",
        idx=f"{index}.1.ht2",
    output:
        "count/{sample}.guidecounts.txt"
    params:
        mm=config["mismatch"],
    threads: config["resources"]["count"]["cpu"]
    resources:
        runtime=config["resources"]["count"]["time"]
    log:
        "logs/count/{sample}.log"
    conda:
        "envs/count.yaml"
    shell:
        "zcat {input.fq} | hisat2 --no-hd -p {threads} -t -N {params.mm} -x {index} - 2> {log} | "
        "sed '/XS:/d' | cut -f3 | sort | uniq -c | sed 's/^ *//' | sed '1d' > {output}"


rule aggregated_counts:
    input:
        files=expand("count/{sample}.guidecounts.txt", sample=SAMPLES)
    output:
        "count/counts-aggregated.tsv"
    params:
        fa=fasta,
    script:
        "scripts/join.py"


#check if control genes are specified for generating null distribution of RRA scores
if config["stats"]["mageck_control_genes"] == "all": #use all genes as controls

    control = ""

else: #use genes from file set in config

    file = config["stats"]["mageck_control_genes"]

    control = f"--control-gene {file}" 


rule mageck:
    input: 
        "count/counts-aggregated.tsv"
    output:
        "mageck/{comparison}/{comparison}_summary.Rnw",
        report("mageck/{comparison}/{comparison}.gene_summary.txt", caption="report/mageck.rst", category="MAGeCK"),
        "mageck/{comparison}/{comparison}.log",
        "mageck/{comparison}/{comparison}.R",
        "mageck/{comparison}/{comparison}.sgrna_summary.txt",
        "mageck/{comparison}/{comparison}.normalized.txt"
    params:
        control=control,
        extra=config["stats"]["extra_mageck_arguments"],
    resources:
        runtime=config["resources"]["stats"]["time"]
    conda:
        "envs/stats.yaml"
    log:
        "logs/mageck/{comparison}.log"
    shell:
        '''
        mageck test --normcounts-to-file -k {input} -t $(echo "{wildcards.comparison}" | awk -F '_vs_' '{{print $1}}' | sed 's/-/,/') -c $(echo "{wildcards.comparison}" | awk -F '_vs_' '{{print $2}}' ) -n mageck/{wildcards.comparison}/{wildcards.comparison} {params.control} {params.extra} 2> {log}
        '''


rule mageck_flute:
    input:
        "mageck/{comparison}/{comparison}.gene_summary.txt",
        "mageck/{comparison}/{comparison}.sgrna_summary.txt"
    output:
        report("mageck_flute/{comparison}/{comparison}.volcano.pdf", caption="report/volcano.rst", category="MAGeCK Flute", subcategory="{comparison}", labels={"Comparison":"{comparison}","Figure": "volcano plot"}),
        report("mageck_flute/{comparison}/{comparison}.dot_pos.pdf", caption="report/dot-plot_pos.rst", category="MAGeCK Flute", subcategory="{comparison}", labels={"Comparison":"{comparison}","Figure": "dot plot enriched genes"}),
        report("mageck_flute/{comparison}/{comparison}.dot_neg.pdf", caption="report/dot-plot_neg.rst", category="MAGeCK Flute", subcategory="{comparison}", labels={"Comparison":"{comparison}","Figure": "dot plot depleted genes"}),
        report("mageck_flute/{comparison}/{comparison}.sgrank.pdf", caption="report/sgrank.rst", category="MAGeCK Flute", subcategory="{comparison}", labels={"Comparison":"{comparison}","Figure": "sgRNA rank"}),
    params:
        spc=config["lib_info"][library]["species"]
    resources:
        runtime=config["resources"]["stats"]["time"]
    conda:
        "envs/flute.yaml"
    script:
        "scripts/flute.R"

    
rule install_bagel2:
    output:
        directory("bagel2_software/"),
    conda:
        "envs/stats.yaml"
    shell:
        "git clone https://github.com/hart-lab/bagel.git {output}"
    

rule convert_count_table:
    input:
        "count/counts-aggregated.tsv"
    output:
        "count/counts-aggregated-bagel2.tsv"
    params:
        fa=fasta,
    resources:
        runtime=config["resources"]["stats"]["time"]
    conda:
        "envs/stats.yaml"
    script:
        "scripts/convert_count_table.py"


rule bagel2fc:
    input:
        "bagel2_software/",
        "count/counts-aggregated-bagel2.tsv",
    output:
        "bagel2/{bcomparison}/{bcomparison}.foldchange"
    resources:
        runtime=config["resources"]["stats"]["time"]
    conda:
        "envs/stats.yaml"
    log:
        "logs/bagel2/fc/{bcomparison}.log"
    script:
        "scripts/bagel2fc.py"


rule bagel2bf:
    input:
        "bagel2_software/",
        "bagel2/{bcomparison}/{bcomparison}.foldchange",
    output:
        "bagel2/{bcomparison}/{bcomparison}.bf"
    params:
        species=config["lib_info"][library]["species"],
    resources:
        runtime=config["resources"]["stats"]["time"]
    conda:
        "envs/stats.yaml"
    log:
        "logs/bagel2/bf_{bcomparison}.log"
    script:
        "scripts/bagel2bf.py"


rule bagel2pr:
    input:
        "bagel2_software/",
        "bagel2/{bcomparison}/{bcomparison}.bf",
    output:
        report("bagel2/{bcomparison}/{bcomparison}.pr", caption="report/bagel2.rst", category="BAGEL2")
    params:
        species=config["lib_info"][library]["species"]
    resources:
        runtime=config["resources"]["stats"]["time"]
    conda:
        "envs/stats.yaml"
    log:
        "logs/bagel2/pr_{bcomparison}.log"
    script:
        "scripts/bagel2pr.py"


rule plot_bf:
    input:
        "bagel2/{bcomparison}/{bcomparison}.bf"
    output:
        report("bagel2_plots/{bcomparison}/{bcomparison}.bf.pdf", caption="report/bagel2_plots.rst", category="BAGEL2 plots", subcategory="{bcomparison}", labels={"Comparison":"{bcomparison}", "Figure":"BF plot"})
    conda:
        "envs/stats.yaml"
    script:
        "scripts/plot_bf.py"


rule plot_pr:
    input:
        "bagel2/{bcomparison}/{bcomparison}.pr"
    output:
        report("bagel2_plots/{bcomparison}/{bcomparison}.pr.pdf", caption="report/bagel2_plots.rst", category="BAGEL2 plots", subcategory="{bcomparison}", labels={"Comparison":"{bcomparison}", "Figure":"Precision-recall plot"})
    conda:
        "envs/stats.yaml"
    script:
        "scripts/plot_pr.py"


rule plot_alignment_rate:
    input:
        expand("logs/count/{sample}.log", sample=SAMPLES)
    output:
        report("count/alignment-rates.pdf", caption="report/alignment-rates.rst", category="Alignment rates")
    params:
        name="plot_alignment_rate",
    script:
        "scripts/plot.py"


rule plot_coverage:
    input:
        "count/counts-aggregated.tsv"
    params:
        name="plot_coverage",
        fa=fasta,
    output:
        report("count/sequence-coverage.pdf", caption="report/plot-coverage.rst", category="Sequence coverage")
    script:
        "scripts/plot.py"







